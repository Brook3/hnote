# 1. 数据类型
MySQL支持的数据类型很多，选择正确的数据类型对于 获得高性能至关重要。在选择时有个简单的原则有助于做出更好的选择。

-----

MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。
## 1.1. 数值类型
类型|大小|范围（有符号）|范围（无符号）|用途
:-:|:-:|:-:|:-:|:-:
TINYINT|1 字节|(-128, 127)|(0, 255)|小整数值
SMALLINT|2 字节|(-32 768, 32 767)|(0, 65 535)|大整数值
MEDIUMINT|3 字节|(-8 388 608, 8 388 607)|(0, 16 777 215)|大整数值
INT或INTEGER|4 字节|(-2 147 483 648, 2 147 483 647)|(0, 4 294 967 295)|大整数值
BIGINT|8 字节|(-9 233 372 036 854 775 808, 9 223 372 036 854 775 807)|(0, 18 446 744 073 709 551 615)|极大整数值
FLOAT|4 字节|(-3.402 823 466 E+38, 1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)|0, (1.175 494 351 E-38, 3.402 823 466 E+38)|单精度浮点数值
DOUBLE|8 字节|(1.797 693 134 862 315 7 E+308, 2.225 073 858 507 201 4 E-308), 0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)|0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)|双精度浮点数值
DECIMAL|对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2|依赖于M和D的值|依赖于M和D的值|小数值


* unsigned 和 zerofill
UNSIGNED 修饰符规定字段只保存正值,即无符号,而mysql字段默认是有符号的。因为不需要保存数字的正、负符号，可以在储时节约一个"位"的空间(即翻一倍)。从而增大这个字段可以存储的值的范围。注意这个修饰符要紧跟在数值类型后面;
ZEROFILL 修饰符规定 0（不是空格）可以用来真补输出的值。使用这个修饰符可以阻止 MySQL 数据库存储负值,如果某列设置为zerofill,那它自动就unsigned。这个值要配合int,tinyint,smallint,midiumint等字段的宽度指示器来用;XXint(M),如果没有zerofill,这个M的宽度指示器是没有意义的.(注意,测试前导0的时候,还是去黑窗口测试;)
整数的宽度指示符M必须与zerofill配合使用，当数值长度小于M时，会在数值前面加上足够的0使得长度达到M。当长度大于等于M时，保持原样。但M的大小不会影响类型的数值范围，即int(4)与int(5)的数值范围大小是一样的。只是保存1245时，int(4)会1245，int(5)会01245。

我们经常会使用命令来创建数据表，而且同时会指定一个长度，如下。但是，这里的长度并非是TINYINT类型存储的最大长度，而是显示的最大长度。

CREATE TABLE `user`(
    `id` TINYINT(2) UNSIGNED
);
这里表示user表的id字段的类型是TINYINT，可以存储的最大数值是255。所以，

在存储数据时，如果存入值小于等于255，如200，虽然超过2位，但是没有超出TINYINT类型长度，所以可以正常保存；如果存入值大于255，如500，那么MySQL会自动保存为TINYINT类型的最大值255。
在查询数据时，不管查询结果为何值，都按实际输出。这里TINYINT(2)中2的作用就是，当需要在查询结果前填充0时，命令中加上ZEROFILL就可以实现，如：
`id` TINYINT(2) UNSIGNED ZEROFILL
这样，查询结果如果是5，那输出就是05。如果指定TINYINT(5)，那输出就是00005，其实实际存储的值还是5，而且存储的数据不会超过255，只是MySQL输出数据时在前面填充了0。
换句话说，在MySQL命令中，字段的类型长度TINYINT(2)、INT(11)不会影响数据的插入，只会在使用ZEROFILL时有用，让查询结果前填充0。不会影响数据的插入，只会在使用ZEROFILL时有用，让查询结果前填充0。
> 为什么mysql存储的值要分有符号和无符号呢?因为一个字节,占8bit;也就1个bit有0和1两种可能,8个bit就是2^8 = 256种可能,也就是0~255;但如果是有符号的话,就得拿一个1bit来存储这个负号,本来8bit只剩7bit,2^7 = 128,也就是-128~127(正数部分包含一个0);



### 1.1.1. 优化建议
* 如果整形数据没有负数，如ID号，建议指定为UNSIGNED无符号类型，容量可以扩大一倍。
* 建议使用TINYINT代替ENUM、BITENUM、SET。
* 避免使用整数的显示宽度，也就是说，不要用INT(10)类似的方法指定字段显示宽度，直接用INT
* 用INT UNSIGNED来存储IPv4地址，用VARBINARY来存储IPv6地址，当然存储之前需要用PHP函数转换。
* DECIMAL最适合保存准确度要求高，而且用于计算的数据，比如价格。但是在使用DECIMAL类型的时候，注意长度设置。
* 建议使用整形类型来运算和存储实数，方法是，实数乘以相应的倍数后再操作。
* 整数通常是最佳的数据类型，因为它速度快，并且能使用AUTO_INCREMENT。



---

MySQL 以一个可选的显示宽度指示器的形式对 SQL 标准进行扩展(如 INT(6),6即是其宽度指示器,该宽度指示器并不会影响int列存储字段的大小,也就是说,超过6位它不会自动截取,依然会存储,只有超过它本身的存储范围才会截取;此处宽度指示器的作用在于该字段是否有zerofill,如果有就未满足6位的部分就会用0来填充)，这样当从数据库检索一个值时，可以把这个值加长到指定的长度。例如，指定一个字段的类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出来时能够自动地用空格填充。需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。
万一我们需要对一个字段存储一个超出许可范围的数字，MySQL 会根据允许范围最接近它的一端截短后再进行存储。还有一个比较特别的地方是，MySQL 会在不合规定的值插入表前自动修改为 0。
## 1.2. 字符串类型
类型|占用长度
:-:|:-:
char|1<=M<=255
varchar|L+1,L<=M,1<=M<=255
tinytext|L+1,L<2^8
text|L+2,L<2^16
mediumtext|L+3,L<2^24
longtext|L+4,L<2^32
tinyblob|L+1,L<2^8
blob|L+2,L<2^16
mediumblob|L+3,L<2^24
longblob|L+4,L<2^32
enum|1或2字节，依赖与枚举数量（最多2^8-1)
set|1，2，3，4或8个字节, 取决于集合成员的数量(最多64个成员）

char（M）：定长字符串，适用于长度相对固定的字符串。长度不满M的字符串，会在后面补空格，使得长度达到M。所以原字符串后面不能有空格，否则在查询出来时会被删除。
varchar（M）：变长字符串，长度L不满M时，不会添加空格，它会再用一个字节来保存长度。所有字符串后的空格会被保留下来。由于变长，所以性能比char差。
XXtext（M）：大文本字符串，不区分大小写，不能用来保存图片。在非严格模式下，字符串长度超过限制时，会进行截断处理。如果截断不是空格，则会出现警告信息。在严格模型下，则会直接报错。实际的长度还会与编码字符集有关。
XXblob（M）：二进制字符串，区分大小写，没有字符集，排序和比较基于列值字节的数值值。在非严格模式下，字符串长度超过限制时，会进行截断处理。如果截断不是空格，则会出现警告信息。在严格模型下，则会直接报错。
enum：在设计表的时候就预先定义枚举的值（值后面的空格会被删除），每次只能从其中选取一个来作为该字段的指，或者设置该字段值为null。这些枚举值会被存储为数字，并且从 1 开始用数字做索引，数字0表示空字符串。使用order by对该列进行排序时，默认会按照索引排序（null最前面，然后到空白字符，最后才是定义的值）。要设置按照ascii排序，必须使用GROUP BY CAST(col AS CHAR)或GROUP BY CONCAT(col)。
set：在设计表就预定义set的值，每次可以从其中选取1个以上的值，也可以设置为null或空白字符串。mysql会用数字保存set值，所保存值的低阶位对应第1个set成员。如果在数值上下文中检索一个值，检索的值的位设置对应组成列值的set成员。例如{‘a’,’b’,’c’}，’a’对应二进制数字001，’b’对应010，’c’对应100.所以输入十进制数字5，会组合成’a’,’c’。可以FIND_IN_SET(要搜索的值，set所在的列)函数或LIKE操作符搜索SET值

### 1.2.1. 111
* BINARY
BINARY不是函数，是类型转换运算符，它用来强制它后面的字符串为一个二进制字符串，可以理解为在字符串比较的时候区分大小写
SELECT BINARY 'ABCD' = 'abcd' as COM1,'ABCD' = 'abcd' as COM2; -- COM1输出为0,COM2输出为1;

* CHAR 和 VARCHAR 类型
CHAR 类型用于定长字符串，并且必须在圆括号内用一个大小修饰符来定义。这个大小修饰符的范围从 0-255。比指定长度大的值将被截短，而比指定长度小的值将会用空格作填补。
CHAR 类型可以使用 BINARY 修饰符。当用于比较运算时，这个修饰符使 CHAR 以二进制方式参于运算，而不是以传统的区分大小写的方式。
CHAR 类型的一个变体是 VARCHAR 类型。它是一种可变长度的字符串类型，并且也必须带有一个范围在 0-255 之间的指示器。
CHAR 和 VARCHGAR 不同之处在于 MYSQL 数据库处理这个指示器的方式：CHAR 把这个大小视为值的大小，不长度不足的情况下就用空格补足。而 VARCHAR 类型把它视为最大值并且只使用存储字符串实际需要的长度（增加一个额外字节来存储字符串本身的长度）来存储值。所以短于指示器长度的 VARCHAR 类型不会被空格填补，但长于指示器的值仍然会被截短。
因为 VARCHAR 类型可以根据实际内容动态改变存储值的长度，所以在不能确定字段需要多少字符时使用 VARCHAR 类型可以大大地节约磁盘空间、提高存储效率。但如果确切知道字符串长度,比如就在50~55之间,那就用 CHAR 因为 CHAR 类型由于本身定长的特性使其性能要高于 VARCHAR;
VARCHAR 类型在使用 BINARY 修饰符时与 CHAR 类型完全相同。
* TEXT 和 BLOB 类型
对于字段长度要求超过 255 个的情况下，MySQL 提供了 TEXT 和 BLOB 两种类型。根据存储数据的大小，它们都有不同的子类型。这些大型的数据用于存储文本块或图像、声音文件等二进制数据类型。
TEXT 和 BLOB 类型在分类和比较上存在区别。BLOB 类型区分大小写，而 TEXT 不区分大小写。大小修饰符不用于各种 BLOB 和 TEXT 子类型。比指定类型支持的最大范围大的值将被自动截短。

## 1.3. 优化建议
* 字符串的长度相差较大用VARCHAR；字符串短，且所有值都接近一个长度用CHAR。
* CHAR和VARCHAR适用于包括人名、邮政编码、电话号码和不超过255个字符长度的任意字母数字组合。那些要用来计算的数字不要用VARCHAR类型保存，因为可能会导致一些与计算相关的问题。换句话说，可能影响到计算的准确性和完整性。
* BINARY和VARBINARY存储的是二进制字符串，与字符集无关。
* BLOB系列存储二进制字符串，与字符集无关。TEXT系列存储非二进制字符串，与字符集相关。一般情况下，你可以认为BLOB是一个更大的VARBINARY；TEXT是一个更大的VARCHAR。
* BLOB和TEXT都不能有默认值。


一个英文字符 占用一个字节; 
汉字：
字符类型若为gbk，每个字符最多占2个字节; 
字符类型若为utf8，每个字符最多占3个字节。
CHAR 和 VARCHAR 类型
CHAR 类型用于定长字符串，并且必须在圆括号内用一个大小修饰符来定义。这个大小修饰符的范围从 0-255。比指定长度大的值将被截短，而比指定长度小的值将会用空格作填补。

CHAR 类型的一个变体是 VARCHAR 类型。它是一种可变长度的字符串类型，并且也必须带有一个范围指示器。

CHAR 和 VARCHGAR 不同之处在于 MYSQL 数据库处理这个指示器的方式：CHAR 把这个大小视为值的大小，不长度不足的情况下就用空格补足。而 VARCHAR 类型把它视为最大值并且只使用存储字符串实际需要的长度（增加一个额外字节来存储字符串本身的长度）来存储值。所以短于指示器长度的 VARCHAR 类型不会被空格填补，但长于指示器的值仍然会被截短。





* 字符串类型的使用
字符串数据类型是一个万能数据类型，可以储存数值、字符串、日期等。
保存数值类型最好不要用字符串数据类型，这样存储的空间显然是会更大，而且在排序时字符串的9是大于22的，其实如果进行运算时mysql会将字符串转换为数值类型，大大降低效果，而且这种转换是不会走原有的索引的。
如果明确数据在一个完整的集合中如男，女，那么可以使用set或enum数据类型，这种数据类型在运算及储存时以数值方式操作，所以效率要比字符串更好，同时空间占用更少。

* VARCHAR与CHAR
VARCHAR是可变长度字符串类型，那么即然长度是可变的就会使用1，2个字节来保存字符的长度，如果长度在255内使用1个字节来保存字符长度，否则使用2个字符来保存长度。由于varchar是根据储存的值来保存数据，所以可以大大节约磁盘空间。
如果数据经常被执行更新操作，由于VARCHAR是根据内容来进行储存的，所以mysql将做更多的工作来完成更新操作，如果新数据长度大于老数据长度一些存储引擎会进行拆分操作处理。同时varchar会完全保留内部所有数据，最典型的说明就是尾部的空格。
* CHAR固定长度的字符串保存类型，CHAR会去掉尾部的空格。在数据长度相近时使用char类型比较合适，比如md5加密的密码用户名等。
如果数据经常进行更新修改操作，那么CHAR更好些，因为char长度固定，性能上要快。

3、字符串类型

     MySQL支持多种字符串类型，每个字符串列可以定义自己的字符集和排序规则，或者说校对规则，这些东西很大程度上影响性能。

     A、VARCHAR和CHAR类型
          VARCHAR类型用于存储变长字符串，它会删除末尾的所有空格，它比定长字符串更省空间，因为它仅使用必要的空间（越短的字符串占用越少），VARCHAR会用1或2个额外字节记录字符串长度，VARCHAR节省了空间，因此对性能是有帮助的，但是因为行是变长的，所以每次UPDATE时会重新计算字符串长度，会比定长多做额外工作。因此不是说VARCHAR就一定能提升性能，同样要分使用场景，如果字符串的最大长度比平均长度大很多，且列的更新很少时则适合用VARCHAR。注意InnoDB会把过长的VARCHAR存储为BLOB，通常人们喜欢将IP地址存储为VARCHAR型，其实IP地址是32位二进制表示的,你可以转为十进制表示，因而不是字符串，用小数是将它分为四段便于阅读。
          CHAR是定长的，每个列无论字符串长度大小都会分配固定存储空间，CHAR适合存储字符很短，或者所有值接近一个长度时，如存储MD5码、SESSION_ID等，对于经常变更的数据CHAR也比VARCHAR好，再一个是对于非常短的列，CHAR比VARCHAR更节省空间，例如使用CHAR(1)和VARCHAR(1)来存储Y或N时，CHAR需要一个字符，而VARCHAR需要两个，因为还有一个长度字节
    B、BLOB和TEXT类型
         它们都是为存储大数据而设计的，BLOB是采用二进制/TEXT采用字符存储。MySQL不能将BLOB和TEXT列全部进行索引（只能做前面某长度的索引，因此在查询SQL时不能用LIKE前模糊匹配，那样就走不到索引了），也不能使用这些索引进行排序。
   技巧：使用枚举代替字符串类型，枚举可以把一些重复的字符串存储成一个预定义的集合，MySQL在存储枚举时非常紧凑，MySQL在列中保存值为枚举中的位置整数。枚举最不好的是字符串是固定的，添加或删除必须使用ALTER TABLE。因此对于未来会改变的字符串，使用枚举不是一个好主意，除非能接受在枚举末尾添加元素，由于枚举有一个映射转换过程，所以枚举虽然能减少存储空间，但是也会增加一些额外开销。


---

## 1.4. 日期和时间
类型|大小(字节)|范围|格式|用途
:-:|:-:|:-:|:-:|:-:
DATE|3|1000-01-01 到 9999-12-31|YYYY-MM-DD|日期值
TIME|3|'-838:59:59' 到 '838:59:59'|HH:MM:SS|时间值或持续时间
YEAR|1|1901 到 2155|YYYY|年份值
DATETIME|8|1000-01-01 00:00:00 到 9999-12-31 23:59:59|YYYY-MM-DD HH:MM:SS|混合日期和时间值
TIMESTAMP|8|1970-01-01 00:00:00 到 2037 年某时|YYYYMMDDhhmmss|混合日期和时间值，时间戳

time：TIME类型不仅可以用于表示一天的时间(必须小于24小时)，还可能为某个事件过去的时间或两个事件之间的时间间隔。没有冒号时，MySQL解释值时假定最右边的两位表示秒。如’1822’表示’00:18:22’。无效TIME值被转换为’00:00:00’。year：非法值转为0000. 
- 四位字符串：范围从’1901’~’2155’ 
- 四位数字：范围从1901~2155 
- 两位字符串：范围从’00’：’99’。’00’~’69转化为’2000’~’2069’，’70’~’99’转化为’1970’~’1999’ 
- 两位数字：范围从1~99.1~69转化为2001~2069，70~99转为1970~1999.

* DATE、TIME 和 YEAR 类型
MySQL 用 DATE 和 YEAR 类型存储简单的日期值，使用 TIME 类型存储时间值。这些类型可以描述为字符串或不带分隔符的整数序列。如果描述为字符串，DATE 类型的值应该使用连字号作为分隔符分开，而 TIME 类型的值应该使用冒号作为分隔符分开。
需要注意的是，没有冒号分隔符的 TIME 类型值，将会被 MySQL 理解为持续的时间，而不是时间戳。
MySQL 还对日期的年份中的两个数字的值，或是 SQL 语句中为 YEAR 类型输入的两个数字进行最大限度的通译。因为所有 YEAR 类型的值必须用 4 个数字存储。MySQL 试图将 2 个数字的年份转换为 4 个数字的值。把在 00-69 范围内的值转换到 2000-2069 范围内。把 70-99 范围内的值转换到 1970-1979 之内。如果 MySQL 自动转换后的值并不符合我们的需要，请输入 4 个数字表示的年份。
* DATETIME 和 TIMESTAMP 类型
除了日期和时间数据类型，MySQL 还支持 DATETIME 和 TIMESTAMP 这两种混合类型。它们可以把日期和时间作为单个的值进行存储。这两种类型通常用于自动存储包含当前日期和时间的时间戳，并可在需要执行大量数据库事务和需要建立一个调试和审查用途的审计跟踪的应用程序中发挥良好作用。
> 如果我们对 TIMESTAMP 类型的字段没有明确赋值，或是被赋与了 null 值。MySQL 会自动使用系统当前的日期和时间来填充它。

---

复合类型
MySQL 还支持两种复合数据类型 ENUM 和 SET，它们扩展了 SQL 规范。虽然这些类型在技术上是字符串类型，但是可以被视为不同的数据类型。一个 ENUM 类型只允许从一个集合中取得一个值；而 SET 类型允许从一个集合中取得任意多个值。

ENUM 类型
ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。ENUM 类型字段可以从集合中取得一个值或使用 null 值，除此之外的输入将会使 MySQL 在这个字段中插入一个空字符串。另外如果插入值的大小写与集合中值的大小写不匹配，MySQL 会自动使用插入值的大小写转换成与集合中大小写一致的值。
ENUM 类型在系统内部可以存储为数字，并且从 1 开始用数字做索引。一个 ENUM 类型最多可以包含 65536 个元素，其中一个元素被 MySQL 保留，用来存储错误信息，这个错误值用索引 0 或者一个空字符串表示。
MySQL 认为 ENUM 类型集合中出现的值是合法输入，除此之外其它任何输入都将失败。这说明通过搜索包含空字符串或对应数字索引为 0 的行就可以很容易地找到错误记录的位置。

SET 类型
SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。并且与 ENUM 类型相同的是任何试图在 SET 类型字段中插入非预定义的值都会使 MySQL 插入一个空字符串。如果插入一个即有合法的元素又有非法的元素的记录，MySQL 将会保留合法的元素，除去非法的元素。
一个 SET 类型最多可以包含 64 项元素。还去除了重复的元素，所以 SET 类型中不可能包含两个相同的元素。
希望从 SET 类型字段中找出非法的记录只需查找包含空字符串或二进制值为 0 的行。

位数据类型
     MySQL有少数几种存储类型使用紧凑的位存储数据。不管底层存储格式如何处理，从技术上说都是字符型。
BIT：BIT(1)表示定义一个包含一位的长度，BIT(2)表示2个位，以此类推，BIT列最大长度是64位，MySQL把BIT当字符串处理，而不是数字，当检索BIT(1)的值时，结果是一个包含二进制0或1的字符串，而不是ASCII码的0或1，例如00111001，它的二进制等于57，检索它时得到是一个字符码为57的字符，也就是ASCII码57对应字符为9。一般在应用中尽量避免使用BIT，对于大部分应用来说最好是不用。
---


# 2. 合理的选择数据类型
## 2.1. 为什么要选择数据类型
数据库类型的选择对数据库的性能影响很大：
* 数据类型会影响存储空间的开销。
* 数据类型会影响数据查询性能
> 因此：优先选择占用空间少的类型，可以用更少的磁盘、内容、CPU缓存，大大减少IO开销。

## 2.2. 怎么选择数据类型
*  所以当一个数据类型可以有多种选择多种类型的时候，应该优先考虑数字类型，其次是日期或二进制类型，最后应该是字符类型。
* 对于相同级别的数据类型，应该优先选择占用空间小的数据类型。原理：在对数据进行比较（查询条件，JOIN条件及排序）操作时：同样的数据，字符处理往往比数字处理慢，而且在数据库中，数据的处理是以页为单位，列的长度越小，数据类型占用的空间越小，利于性能的提升。

## 2.3. 选择原则
* 字段类型选择
	原则：选择相对简单的数据类型
	占用空间较小、数据长度最好固定、数据内容最好为整型。数字类型相对字符串类型要简单的多，尤其是在比较运算时，所以我们应该选择最简单的数据类型。
* 选择合理范围内最小的
	我们应该选择最小的数据范围，因为这样可以大大减少磁盘空间及磁盘I/0读写开销，减少内存占用，减少CPU的占用率。
* 尽量避免使用NULL
     NULL是列默认的属性，通常我们要指定为NOT NULL。有NULL的列值会使得索引、索引统计和值比较更加复杂。可为NULL的列会使用更多的存储空间，在MySQL中也需要对它进行特殊处理，当可为NULL列做索引时，每个索引需要一个额外的字节，在MyISAM更有可能导致固定大小的索引变成可变大小索引，在InnoDB中使用单独的位(bit)存储NULL值。

### 2.3.1. 数值型
数值数据类型要比字符串执行更快，区间小的数据类型占用空间更少，处理速度更快，如tinyint可比bigint要快的多
选择数据类型时要考虑内容长度，比如是保存毫米单位还是米而选择不同的数值类型

### 2.3.2. 数值型-整数
* 从范围选择
Tinyint,SmallInt,Mediumint,Int,Bingint该如何选择：
1 .从 0 到 255 的整型数据。存储大小为 1 字节。适合使用Tinyint
2.从 -2^15 (-32,768) 到 2^15 - 1 (32,767) 的整型数据。存储大小为 2 个字节。适合使用smallint
3.从 -2^31 (-2,147,483,648) 到 2^31 - 1 (2,147,483,647) 的整型数据（所有数字）。存储大小为 4 个字节。int 的 SQL-92 同义字为 integer。适合使用int
4.从 -2^63 (-9223372036854775808) 到 2^63-1 (9223372036854775807) 的整型数据（所有数字）。存储大小为 8 个字节。
适合使用bigint
* 善用UNSIGNED

### 2.3.3. 数值型-实数类型
* 浮点数与精度数值
1. 浮点数float在储存空间及运行效率上要优于精度数值类型decimal，但float与double会有舍入错误，而decimal则可以提供更加准确的小数级精确运算不会有错误产生计算更精确，适用于金融类型数据的存储。
2. 实数是带小数部分的数字，然而它不只是为了存储小数部分，也可以使用DECIMAL存储比BIGINT还大的整数，FLOAT和DOUBLE类型支持使用标准的浮点运算进行四舍五入。DECIMAL用于存储精确的小数。FLOAT占用4个字节，DOBULE占用8个字节，它比DECIMAL占用空间更小、计算浮更更快，因此在非存储财务数据时，可以考虑其它的类型，如放大N倍后存为BIGINT。
3. 在涉及到金额的时候如果对精度要求不高的情况下可以优先使用float，其次是使用double来进存储。如果对精度要求比较高的情况下最好使用decimal来存储，但是相应的它 的效率没有float和double那么高效。具体使用哪种还是要根据业务的具体需求来选择。
由于float的存储空间的开销一般比decimal小（精确到7为小数只需要4个字节，而精确到15位小数只需要8个字节）故非精确数据类型建议使用float
4. 浮点数的宽度指示符M与整数的不一样，它表示数字总的个数。浮点数和定点数都可以设置小数点的位数D（D<=M）。所以（M，D）表示的数的范围为：总长度为M，小数点后保留D位，超过D位进行四舍五入处理。decimal比float更加准确，占用空间也比较少，建议使用decimal。
FLOAT 类型在长度比较高比如 float(10,2)和 decimal(10,2)同时插入一个符合(10,2)宽度的数值,float 就会出现最后小数点出现一些出入;

### 2.3.4. 字符串
1.如果列中要存储的数据是字符，且长度是一个固定区间定值或长度差不多是一致的，则应该考虑char，否则应该考虑用varchar.
2.如果列中最大数据的长度小于50Byte，则一般也考虑使用char(当然，如果这个列很少用，则基于节省空加你和减少I/O的考虑，还是可以使用varchar)
3.一般不宜定义大雨50Byte的char类型列。注意：utf8每一个字符时3Byte
4. 不管使用的是哪种字段来进行存储，都不要把字段的初始长度设置为最大化，应该是根据业务需求来存储最合适的长度字段。

> 因为 VARCHAR 类型可以根据实际内容动态改变存储值的长度，所以在不能确定字段需要多少字符时使用 VARCHAR类型可以大大地节约磁盘空间、提高存储效率。但如果确切知道字符串长度,比如就在50~55之间,那就用 CHAR 因为 CHAR
类型由于本身定长的特性使其性能要高于 VARCHAR;
### 2.3.5. 时间
* 除了特殊情况外，通常我们应该尽量使用TIMESTAMP，因为它比DATETIME更省空间
* 注意时间范围
* 如果仅仅是想要精确到天的话使用date就可以了，如要要精确到秒一级别的就要使用datetime了。有时候大家使用datetime的使用却只是存储到天的日期单位时，这个时候就会自动添加00:00:00在数据的后面，作为秒一级别的数据。
* 用MySQL的内建类型DATE、TIME、DATETIME来存储时间，而不是使用字符串。
* 当数据格式为TIMESTAMP和DATETIME时，可以用CURRENT_TIMESTAMP作为默认（MySQL5.6以后），MySQL会自动返回记录插入的确切时间。
* TIMESTAMP是UTC时间戳，与时区相关。
* DATETIME的存储格式是一个YYYYMMDD HH:MM:SS的整数，与时区无关，你存了什么，读出来就是什么。
* 除非有特殊需求，否则建议使用TIMESTAMP，它比DATETIME更节约空间。
* 有时人们把Unix的时间戳保存为整数值，但是这通常没有任何好处，这种格式处理起来不太方便，我们并不推荐它。




# 3. 总结
    虽然上面列出了很多字段类型,但最常用也就是 varchar(255),char(255),text,tinyint(4),smallint(6),mediumint,int(11)几种。
复合类型我们一般用tinyint,更快的时间更省的空间以及更容易扩展
## 3.1. 常用字段举例
* 手机号或者邮箱的类型选择
    推荐用char(11),char(11)在查询上更有效率，因为手机号是一个活跃字段参与逻辑会很多
* 姓名：char(20)
* 价格：DECIMAL(7, 3)
* 产品序列号：SMALLINT(5) unsigned
* 文章内容: TEXT
* MD5: CHAR(32)
* ip: char(15)
* time: int(10)
* email char(32)
* 金额字段选择
1.decimal
decimal(M,N) 0<M<65,0<N<30,且N<M,M和N的长度直接影响存储空间
默认情况，表示金额的情况，decimal(16,2), 范围是 99,999,999,999,999.99 to -99,999,999,999,999.99
占用空间为 8 个字节
存储时会四舍五入
2.bigint
占用空间为 8 个字节
存储相同大写的数字是，decimal 比 bigint 多 1 个字节
存入数据库时，decimal 会做四舍五入
create table ta (a decimal(4,2),b int);
insert into ta (a,b) values(99.006,9900);
select * from ta;
```mysql
+-------+------+
| a     | b    |
+-------+------+
| 99.01 | 9900 |
+-------+------+
```
总结：
1. decimal&bigtin 在做计算时，都不会丢失精度（float&double 在极端情况下会丢失精度），但是在存入 mysql 数据库时，decimal 会做四舍五入，而 int 不存在这种情况。
2. 金额字段使用 decimal 类型时，默认单位为元，比较直观，没有歧义
3. 金额字段使用 bigint 时，需要特殊说明单位为分，程序处理时，可以直接使用整数类型 long，较通用
4. 存储相关大小的金额时（bigint 以分为单位），decimal 占用空间比 bigint 微大
综上所诉：建议用 bigint 来存储金额
*  时间字段类型的选择
法一： https://www.linuxprobe.com/mysql-time.html
法二：https://learnku.com/laravel/t/2495/select-the-appropriate-mysql-date-time-type-to-store-your-time
法三：
1.timestamp
占用 4 个字节
时区转化 ，存储时对当前的时区进行转换，检索时再转换回当前的时区，对于跨时区跨机房的主从同步有影响
默认值为 CURRENT_TIMESTAMP()，其实也就是当前的系统时间
timestamp 容易受 mysql sqlmode，timezone 参数影响，局限性大
支持范围 1970-01-01 08:00:01 ~ 2038-01-19 11:14:07
不推荐使用
2.bigint
占用 8 个字节
与时区有关，通过 System.currentTimeMillis() 获取
建立索引之后，查询速度快，条件范围搜索可以使用使用 between
支持范围 1970-01-01 08:00:01 ~ 2038-01-19 11:14:07 支持精确到毫秒级别
PS: 适合需要进行大量时间范围查询的数据表
3.datetime
占用 8 个字节
允许为空值，可以自定义值，系统不会自动修改其值
与时区无关
不可以设定默认值，所以在不允许为空值的情况下，必须手动指定 datetime 字段的值才可以成功插入数据
可以在指定 datetime 字段的值的时候使用 now() 变量来自动插入系统的当前时间
支持范围：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
法四：
保存时间通常有这几种类型可以选择：
datetime
timestamp
int
date
首先看看datetime，datetime这个类型可以保存从1001年到9999年的数据，内部是将日期和时间封装在YYYYMMDDHHMMSS的整数中，与时区无关，占用8个字节。
timestamp，timestamp只能保存1970年到2038年，占用4个字节，和int所占用的字节是一样的。
int，int占用的同样是4个字节，和timestamp一样，但是timestamp拥有一些特殊的效果，比如插入的时候如果没有指定数值，会自动填入当前的时间。
date，date同样也是内部将日期封装在YYYYMMDD整数中，因此需要占用4个字节。
存储时间没有一个通用的最佳的选择，只能是根据需求来得到最佳的存储类型。
总结：
1. 性能：bigint 性能最高，如果程序有通过时间排序的场景，优势巨大
2. 通用性：bigint 不受平台限制，所有系统都能通用，不会对后期的升级迁移造成困扰
3. 精度：bigint 能够精确到毫秒级别，对于高并发，高精度查询，帮助大
4. 可读性：bigint 不如 datetime, 开发成本大


## 3.2. int(11)最大长度是多少？
在SQL语句中int代表你要创建字段的类型，int代表整型，11代表字段的长度。
　　这个11代表显示宽度，整数列的显示宽度与mysql需要用多少个字符来显示该列数值，与该整数需要的存储空间的大小都没有关系，比如，不管设定了显示宽度是多少个字符，bigint都要占用8个字节。
　　int是整型，(11)是指显示字符的长度，但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0
　　声明整型数据列时，我们可以为它指定个显示宽度M(1~255)，如INT(5)，指定显示宽度为5个字符,如果没有给它指定显示宽度，MySQL会为它指定一个默认值。显示宽度只用于显示，并不能限制取值范围和占用空间，如：INT(3)会占用4个字节的存储空间，并且允许的最大值也不会是999,而是 INT整型所允许的最大值。
在整型数据列后加上UNSIGNED属性可以禁止负数，取值从0开始。

## 3.3. varchar最大长度是多少？
4.0版本以下，varchar(20)，指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） 
5.0版本以上，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放20个，最大大小是65532字节 
Mysql4中最大也不过是20个字节,但是Mysql5根据编码不同,存储大小也不同。
在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）．

### 3.3.1. varchar最大长度是多少？
　　这不是一个固定的数字。先简要说明一下限制规则。
　　1、限制规则
　　字段的限制在字段定义的时候有以下规则：
　　a) 存储限制
　　varchar 字段是将实际内容单独存储在聚簇索引之外，内容开头用1到2个字节表示实际长度（长度超过255时需要2个字节），因此最大长度不能超过65535。
　　b) 编码长度限制
　　字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766;
　　字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845。
　　若定义的时候超过上述限制，则varchar字段会被强行转为text类型，并产生warning。
　　c) 行长度限制
　　导致实际应用中varchar长度限制的是一个行定义的长度。 MySQL要求一个行的定义长度不能超过65535。若定义的表长度超过这个值，则提示
　　ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to change some columns to TEXT or BLOBs。
　　2、计算例子
　　举两个例说明一下实际长度的计算。
　　a) 若一个表只有一个varchar类型，如定义为
　　create table t4(c varchar(N)) charset=gbk;
　　则此处N的最大值为(65535-1-2)/2= 32766。
　　减1的原因是实际行存储从第二个字节开始’;
　　减2的原因是varchar头部的2个字节表示长度;
　　除2的原因是字符编码是gbk。
5.int（5）和int（10）的区别是什么？想必大家也很好奇吧，其实5和10其实只是显示长度的却别而已，也就是不管int（x）x的值是什么值，存储数字的取值范围还是int本身数据类型的取值范围，x只是数据显示的长度而已。

6.varchar（10）和char（10）的差别是什么？存储超过时候会发生什么问题呢？这个问题其实也相对经典，我也是整了很久才搞清楚的。在MYSQL5,5以后，varchar（x）x中范其实是存储字段的长度范围，就是一个字符代表一个长度，不管这个字符是汉子还是字符都算是一个长度单位。varchar虽然设置长度值，可是因为varchar是可变的长度类型，也就是当存储的长度小于x时候，其实实际的存储空间不是x而是实际存储的字符长度+一些标示空间。当然如果超过x的长度的话还是会报错的。而char（y）中y的值就是存储空间实际的存储长度，超过这个长度的话就会报错。